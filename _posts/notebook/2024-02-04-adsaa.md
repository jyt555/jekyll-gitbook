---
title: ADSAA
author: jyt555
date: 2024-02-04
category: pages/notebook
layout: post
mermaid: true
---

# 。

## starting

### grading policy

60 ( 10 hw + 10 discussions + 30 PR + 10 midterm) | 40 final exam

### project

initial version - 7 days

ALL Groups pr - 2 days

revise and submit - 2 days

## AVL Trees, Splay Trees, Amortized Analysis

### AVL Trees (Adelson-Velskii-Landis)

* Target: speed up searching
* Tool: binary search trees
* Problem: Although Tp = O(height), the height can be as bad as O(N)

【Definition】An **empty** binary tree is height balanced. If T is a nonempty binary tree with TL and TR as its left and right subtrees, then T is height balanced iff

  (1) TL and TR are height balanced, and

  (2) $\mid hL-hR\mid\le 1$ where hL and hR are the heights of TL and TR , respectively.

【Definition】The `balance factor BF(node)` = hL - hR. In an AVL tree, BF(node) = -1, 0, or 1.

### The rotation operations on a BST

![](../../assets/notebook/Snipaste_2024-02-26_10-41-35.png)

![](../../assets/notebook/Snipaste_2024-02-26_10-54-04.png)

![](../../assets/notebook/Snipaste_2024-02-26_11-14-20.png)

| trouble maker 和 trouble finder 的关系决定树该如何调整 |

Obviously we have Tp **=** O(h), where h is the height of the tree. **h = O(ln n)**

### Splay Trees

> ##### from [Isshiki修](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/)
>
> Splay 树，即伸展树，想要解决的问题和 AVL 树类似，只不过 Splay 树希望达到的目标是在**摊还(Amortized)**复杂度O(logN)的情况下完成大部分对点操作。
>
> 我们知道，为使 AVL 保持平衡，我们需要维护从根节点到 Trouble Maker 这条路径上所有点的平衡因子。而 Splay 则不再维护这些信息，这意味着我们无法保证 Splay 树的状态都是平衡的，但是我们希望它尽可能平衡。具体来说就是对于M次任意操作，其时间复杂度都为O*(*MlogN)，均摊下来这 M 个操作每一个都需要O(logN)。
{: .block-tip }

* Target: M consecutive tree operations **starting from an empty tree** take at most O(M log N) times – the **amortized(均摊) time** is O(log N)
* Idea: after a node is accessed, it is **pushed to the root** by a series of AVL tree rotations

|仅凭上述LL/LR/RL/RR无法较好实现目标（可以参照PPT上 trouble maker [BF=0] 与 trouble finder [BF=2] 直接相连的例子或是只有左/右子树的例子），因此我们 try again :point_down: |

![](../../assets/notebook/Snipaste_2024-02-26_11-44-14.png)

> ##### tip
> 
> 可以简单记忆为`G`、`P`、`X`的上下关系颠倒，`X`的子树尽可能让处在下位的节点分担。（zig-zag后`X`左右均有节点，因此子树`B`与`C`均能下移，zig-zig后`X`只有一边有节点，只能下移子树`B`。）
{: .block-warning}

| Splaying not only moves the accessed node to the root, but also roughly halves the depth of most nodes on the path. |

* Deletions: Find X (X will be at the root) - Remove X - FindMax(TL) - Move it

### Amortized Analysis (:star:mark)

* Target: **Any M consecutive operations** take at most O(M log N) time – `Amortized time bound`
  worst-case bound $\ge$ amortized bound $\ge$ average-case bound

#### Aggregate analysis

Show that for all n, a sequence of n operations takes **worst-case** time T(n) in total. In the worst case, the average cost, or amortized cost, per operation is therefore T(n)/n.

aggregate analysis 聚合法 | $T_{amortized}=T(n)/n$

#### Accounting method

When an operation’s **amortized cost** $\hat c_i$ exceeds its **actual cost** $c_i$, we assign the difference to specific objects in the data structure as **credit**. Credit can help **pay** for later operations whose amortized cost is less than their actual cost.

accounting method 核法 | $T_{amortized}=\frac{\sum_{i=1}^n\hat{c}_i\geq\sum_{i=1}^nc_i}n$​

> ##### Link
>
> [https://www.baeldung.com/cs/amortized-analysis](https://www.baeldung.com/cs/amortized-analysis)
{: .block-tip}

#### Potential method

