---
title: ADSAA
author: jyt555
date: 2024-02-04
category: pages/notebook
layout: post
mermaid: true
---

# 。

## starting

| 之前的FDS笔记pdf网页版:point_right: [FDS](https://jyt555.github.io/zju_cs/FDS/) |

### grading policy

60 ( 10 hw + 10 discussions + 30 PR + 10 midterm) | 40 final exam

### project

initial version - 7 days

ALL Groups pr - 2 days

revise and submit - 2 days

## AVL Trees, Splay Trees, Amortized Analysis

### AVL Trees (Adelson-Velskii-Landis)

* Target: speed up searching
* Tool: binary search trees
* Problem: Although Tp = O(height), the height can be as bad as O(N)

【Definition】An **empty** binary tree is height balanced. If T is a nonempty binary tree with TL and TR as its left and right subtrees, then T is height balanced iff

  (1) TL and TR are height balanced, and

  (2) $\mid hL-hR\mid\le 1$ where hL and hR are the heights of TL and TR , respectively.

【Definition】The `balance factor BF(node)` = hL - hR. In an AVL tree, BF(node) = -1, 0, or 1.

### The rotation operations on a BST

![](../../assets/notebook/Snipaste_2024-02-26_10-41-35.png)

![](../../assets/notebook/Snipaste_2024-02-26_10-54-04.png)

![](../../assets/notebook/Snipaste_2024-02-26_11-14-20.png)

| trouble maker 和 trouble finder 的关系决定树该如何调整 |

Obviously we have Tp **=** O(h), where h is the height of the tree. **h = O(ln n)**

### Splay Trees

> ##### from [Isshiki修](https://note.isshikih.top/cour_note/D2CX_AdvancedDataStructure/)
>
> Splay 树，即伸展树，想要解决的问题和 AVL 树类似，只不过 Splay 树希望达到的目标是在**摊还(Amortized)**复杂度O(logN)的情况下完成大部分对点操作。
>
> 我们知道，为使 AVL 保持平衡，我们需要维护从根节点到 Trouble Maker 这条路径上所有点的平衡因子。而 Splay 则不再维护这些信息，这意味着我们无法保证 Splay 树的状态都是平衡的，但是我们希望它尽可能平衡。具体来说就是对于M次任意操作，其时间复杂度都为O*(*MlogN)，均摊下来这 M 个操作每一个都需要O(logN)。
{: .block-tip }

* Target: M consecutive tree operations **starting from an empty tree** take at most O(M log N) times – the **amortized(均摊) time** is O(log N)
* Idea: after a node is accessed, it is **pushed to the root** by a series of AVL tree rotations

|仅凭上述LL/LR/RL/RR无法较好实现目标（可以参照PPT上 trouble maker [BF=0] 与 trouble finder [BF=2] 直接相连的例子或是只有左/右子树的例子），因此我们 try again :point_down: |

![](../../assets/notebook/Snipaste_2024-02-26_11-44-14.png)

> ##### tip
> 
> 可以简单记忆为G、P、X的上下关系颠倒，X的子树尽可能让处在下位的节点分担。（zig-zag后X左右均有节点，因此子树B与C均能下移，zig-zig后X只有一边有节点，只能下移子树B。）
{: .block-warning}

| Splaying not only moves the accessed node to the root, but also roughly halves the depth of most nodes on the path. |

* Deletions: Find X (X will be at the root) - Remove X - FindMax(TL) - Move it

### Amortized Analysis (:star:mark)

* Target: **Any M consecutive operations** take at most O(M log N) time – `Amortized time bound`
  worst-case bound $\ge$ amortized bound $\ge$ average-case bound

#### Aggregate analysis

Show that for all n, a sequence of n operations takes **worst-case** time T(n) in total. In the worst case, the average cost, or amortized cost, per operation is therefore T(n)/n.

`aggregate analysis 聚合法` | $T_{amortized}=T(n)/n$​

#### Accounting method

When an operation’s **amortized cost** $\hat c_i$ exceeds its **actual cost** $c_i$, we assign the difference to specific objects in the data structure as **credit**. Credit can help **pay** for later operations whose amortized cost is less than their actual cost.

`accounting method 核法` | $T_{amortized}=\sum_{i=1}^n\hat{c}_i/n \geq \sum_{i=1}^nc_i/n$

> ##### Link
>
> [https://www.baeldung.com/cs/amortized-analysis](https://www.baeldung.com/cs/amortized-analysis)
> {: .block-tip}

#### Potential method

a good potential function should always assume its **minimum** at the start of the sequence.

`potential method 势能法` | 404 Not found…

> ##### Link – 鱼肆周报 002
> 
> [https://www.yuque.com/xianyuxuan/saltfish_shop/weekly002_amortized_analysis#KmnY6](https://www.yuque.com/xianyuxuan/saltfish_shop/weekly002_amortized_analysis#KmnY6)
{: .block-tip}


> ##### Plus
> 
> For potential method, a good potential function should always assume its maximum at the start of the sequence :x:
{: .block-danger}

## Red-Black Trees and B+ Trees

### Red-Black Trees

> Target: Balanced binary search tree

【Definition】A `red-black tree` is a binary search tree that satisfies the following properties:

* Every node is either red or black
* The **root is black**
* Every **leaf (NIL) is black**
* If a node is red, then both its children are black
* For each node, all simple paths from the node to descendant leaves contain the **same number of black nodes**

external nod(aVL]]dv,Ie, internaydnide

【Definition】The `black-height` of any node x, denoted by `bh(x)`, is the number of black nodes on any simple path from x down to a leaf. bh(Tree) = bh(root)

【Lemma】 A red-black tree with N internal nodes has height at most 2ln(N+1)

![](../../assets/notebook/Snipaste_2024-03-04_11-17-05.png)

| Insertion：通过重新染色和旋转来解决，最多两个旋转可以解决 |

对于Delete操作，adjust only if the node is black

。Delete

Number of Rotations:

|           | AVL     | Red-Black Tree |
| :-------: | ------- | -------------- |
| Insertion | $\le 2$ | $\le 2$        |
| Deletion  | O(logN) | $\le 3$        |

### B+ Trees

【Definition】A `B+ tree` of order **M** is a tree with the following structural properties**:**

* The root is either a leaf or has between 2 and M children
* All nonleaf nodes (except the root) have between |^M/2 and M children
*  All leaves are at the same depth (Assume each nonroot leaf also has between éM/2ù and M children)

。

