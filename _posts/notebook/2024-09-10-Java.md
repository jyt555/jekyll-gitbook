---
title: Java
author: jyt555
date: 2024-09-10
category: pages/notebook
layout: post
mermaid: true

---

# 。

### intro

![](../../assets/3.1-nb/Snipaste_2024-09-10_14-37-26.png)

### Grading

| 平时 70 | 期末 30 (PTA)，斩杀

平时 = 出勤+HW(PTA)+小程+大程+（maybe）mid-exam(PTA)

开卷，可以带一本书，不能带笔记

`ftp://java:java123456@10.15.62.53:211`

建议用filezilla等客户端

笔记中还没弄清楚的内容：:cactus:标记

### something

Write once, compile, run anywhere!

![](../../assets/3.1-nb/Snipaste_2024-09-10_15-11-30.png)

## 1-Introduction

版本很多，学的基本是Java-6/7/8的基础知识

Java SE 8

Characteristics: simple, object-oriented, distributed, interpreted, robust, multithread, dynamic.

- With Java, you write the program once, and compile the source program into a special type of object code, known as **bytecode.**
- The bytecode can then run on any computer with a Java Virtual Machine.
- **Java Virtual Machine** is a software that interprets Java bytecode.

![](../../assets/3.1-nb/Snipaste_2024-09-10_23-13-04.png)

- Every Java program must have at least one class. (start with an uppercase letter) e.g. Welcome

- Line 2 defines the main method. In order to run a class, the class must contain a method named main.
- A statement represents an action or a sequence of actions.

```java
public class Welcome {
    public static void main (String[] args) {
        System.out.println("Welcome to Java!");
    }
}
```

## 2-Elementary Programming

```java
import java.util.Scanner;

public class ComputerAreaWithConsoleInput {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        
        System.out.print("Enter a radium:");
        double radium = input.nextDouble();
        
        System.out.println("The area... " + radius + " is " + area);
    }
}
```

### Identifiers

consists of **letters, digits, underscores (_), and dollar signs ($).**

It cannot start with a digit.

It cannot be a reserved word.

It cannot be *true, false,* or *null*.

区分大小写：Int-:o: int-:x:

> :question:Which one below is NOT a valid Java identifier?
>
> A.Int	:o:B.goto	C.变量	D.$0

### 与c++区别

C/C++中`int i = 10;`是个定义，`external int i;`则是声明；在Java中不区分变量的声明与定义。

Java assigns **no default** value to a **local variable** inside a method. 对于<u>方法的局部变量</u>，java以编译错误来保证变量在使用前得到恰当初始化；而对于<u>类中的局部变量</u>，在声明类的对象时，每个基本类型的变量都会有一个初始值。

> ```java
> public class  Person{
>     static int arr[] = new int[5];
>     public static void main(String a[]) {
>         System.out.println(arr[0]);
>     }
> }
> ```
>
> :o:Prints 0

### Named Constants

`final datatype CONSTANTNAME = VALUE;`

对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便**不能更改**；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。

:anchor: `final double PI = 3.14159;`

> :question:Given a public member variable MAX_LENGTH as the int type is a constant of 100, the correct statement to define the variable is:
>
> A. public int MAX_LENGTH = 100
>
> :o:B. final int MAX_LENGTH = 100
>
> C. public const int MAX_LENGTH = 100
>
> D. public final int MAX_LENGTH = 100

### final VS. const

final修饰变量：变量不可改变，但是值可以在运行时初始化`final int i1 = (int)(Math.Random() * 10)；`/编译时初始化`final i2 = 1;`/构造函数中初始化`final i3;`

> final修饰类对象，对象可以更改，但是变量不可赋成其他对象link： [Java中Final修饰对象](https://blog.csdn.net/amuchena/article/details/110312400)

final修饰方法：函数不可更改，即不能被重载，不是修饰返回值的

final修饰类：整个类不能被继承，类里所有方法相当于被加了final

### Naming Conventions

- Variables and method names: lowercase - `radius`
- Class names: Capitalize the first letter of each word - `ComputerArea`
- Constants: Uppercase - `MAX_VALUE`

### Numerical Data Types

byte - 8 bits, short - 16 bits, int - 32 bits, long - 64 bits

Java中，整型的范围与运行Java代码的机器无关，没有`sizeof()`

:anchor:Calculations involving floating-point numbers are approximated because these numbers are not stored with complete accuracy.

:anchor:Integers are stored precisely.

### Number Literals

`byte b = 1000` :x: compilation error

An integer literal is assumed to be of the `int` type ($-2^{31}\sim 2^{31}-1$). To denote an integer literal of the `long` type, append it with the letter $L\text{ or } l$.

By default, a floating-point literal is treated as a `double` type value. Float - $F\text{ or }f$, double - $D\text{ or }d$.

```java
System.out.println("1.0 / 3.0 is " + 1.0 / 3.0);
// 1.0 / 3.0 is 0.3333333333333333
System.out.println("1.0F / 3.0F is " + 1.0F / 3.0F);
// 1.0F / 3.0F is 0.33333334
```

正无穷大：`Double.POSITIVE_INFINITY`

负无穷大：`Double.NEGATIVE_INFINITY`

Not a Number：`Double.NaN`

### Numeric Type Conversion

When performing a binary operation involving two operands of different types, Java automatically converts the operand based on the following rules:

如果一个操作数是xx，另一个就转化成xx，转化顺序`double` > `float` > `long` > `int`

### Type Casting

类型转换（实线无信息丢失，虚线可能有精度损失）：

<img src="../../assets/3.1-nb/Snipaste_2024-09-27_11-08-33.png" style="zoom:50%;" />

隐式（implicit）：`double d = 3;`

显式（explicit）：`int i = (int)3.9;`

> :question:double x = 9.997, 求四舍五入后的整数
>
> `int nx = (int)Math.round(x);`
>
> 为什么需要强制转化？返回结果是long类型`int round(float x), long round(double x)`

`x1 op= x2` is implemented as `x1 = (T)(x1 op x2)`, T is the type for $x1$.

> ```java
> int sum = 0;
> sum += 4.5;
> // sum becomes 4
> ```

Java不支持c++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。

> ```c++
> int ai; double ad = 1.2; ai = ad;
> ```
>
> 在C++编译器中最多出现警告，但是Java中不予通过。

## 3-Selections

`boolean` type and operators

one-way/two-way/… `if` statements

> `boolean even`:
>
> `if (even == true)` equivalent to `if (even)` :o:
>
> `if (even != 0)` :x:（类型不同）

左结合右结合

![](../../assets/3.1-nb/Snipaste_2024-09-21_14-50-59.png)

> :question:i = 6; -i++ = ?
>
> :o:“-”和“++”同一优先级，且为右结合，原式等价于-(i++)=-6

`switch` statements

```java
switch(switch_expression) {
    case value1: statement(s)1;
        break;
    ...
    default: statement(s);
}
```

:anchor:The <u>switch-expression</u> must yield a value of **char, byte, short, or int** type and must always be enclosed in parentheses.
(Java 1.7后支持了对string的判断，long:x:, boolean:x:)

`(boolean-expression)?expression1:expression2`: conditional expressions

```java
System.out.println(
	(num%2==0) ? num+"is even" : num+"is odd");
```

Associativity: All binary operators except assignment operators are left-associative.

> :o:a = b += c = 5 is equivalent to a = (b += (c = 5))

## 4-Mathematical…

| Mathematical Functions, Characters, and Strings |

### The Math Class

Class constants: `PI, E`

Class methods:

- Trigonometric Methods: `sin(double a), asin(double a)...`

  :anchor:`Math.sin(Math.PI / 2)` returns `1.0`

- Exponent Methods: `exp(double a), log, pow, sqrt`

  :anchor:`Math.pow(2, 3)` return `8.0`

- Rounding Methods:
  `double ceil(double x), double floor(double x)`
  `double rint(double x)` x is rounded to nearest integer (equally close: returns even one)
  `int round(float x), long round(double x)` returns `()Math.floor(x+0.5)`即四舍五入

- `min(a, b), max(a, b), abs(a), random()`

  0 <= Math.random() < 1.0
  :anchor:`a + Math.random() * b` => [a, a+b)

### Character Data Type

The **increment and decrement operators** can also be used on char variables to get the next or preceding Unicode character.

> :o:display character ‘b‘:
>
> ```java
> char ch = 'a';
> System.out.println(++ch);
> ```

**Unicode**: 16 bits (2 bytes), preceded by `\u`, from `\u0000` to `\uFFFF`(can represent 65535 + 1 characters)

| Characters |   ASCII   |       Unicode        |
| :--------: | :-------: | :------------------: |
| ‘0’ to ‘9’ | 48 to 57  | `\u0030` to `\u0039` |
| ‘A’ to ‘Z’ | 65 to 90  | `\u0041` to `\u005A` |
| ‘a’ to ‘z’ | 97 to 122 | `\u0061` to `\u007A` |

ASCII Character Set is a **subset** of the Unicode from `\u0000` to `\u007f`

> :warning:注意注释中的`\u`，会被理解成是Unicode
>
> 例如：`// \u000A` is a newline
>
> `// Look inside c:\users` 会出现语法错误，因为`\u`后面不是四个十六进制数

### String

- `isDigit(ch)`, `isLowerCase(ch)`, `toUpperCase(ch)`…

String is actually a predefined class in the Java library just like the System class and Scanner class. The String type is not a primitive type. It is known as a *reference type*.

- `charAt(0)`, `length()`, `trim()`…
- `substring(beginIndex, endIndex)`, `indexOf(ch)`…

> ```java
> class Main {
>     public static void main(String[] args) {
>         String s1 = "Zhejiang University";
>         String s2 = s1.substring(0, 7);
>         s2.toUpperCase();	// 没有改变s2
>         System.out.println(S2+s1.substring(8));
>     }
> }
> ```
>
> :o:Zhejian University

### Input

```java
Scanner input = new Scanner(System.in);
System.out.print("Enter a word:");
String s = input.next();
System.out.println("s is " + s);
```

- `next()`从遇到第一个有效字符（非空格、换行符）开始扫描，遇到第一个分隔符或结束符（空格`‘ ’`或者换行符`‘\n’`）时结束。

- `nextLine()`则是扫描剩下的所有字符串直到遇到回车为止。（可以从空格开始）

```java
Scanner sc = new Scanner(System.in);
// input:aaa bbb ccc
str1 = sc.next();	// str1 = "aaa"
str2 = sc.nextline();	// str2 = " bbb ccc"
```

### Formatting Output

`System.out.printf(format, items);`

占位符完整格式为：`%[indexs$][标识]*[最小宽度][.精度]转换符`

标识：

- `-`：在最小宽度内左对齐，不可与`0`标识一起使用
- `0`：内容长度不足最小宽度时，在左边填充`0`
- `#`：八进制（转换符`o`）前添`0`，十六进制（`x`）前添`0x`
- `+`：结果总含`+/-`
- ` `（空格）：正数前加空格，负数前加`-`
- `,`：只用于十进制，每三位数字之间用`,`分隔
- `(`：若结果为负数，用括号括住，且不显示符号

> ```java
> int num = -1000;
> String str = String.format("%(,d", num);
> ```
>
> :o:(1,000)

![](../../assets/3.1-nb/Snipaste_2024-09-22_23-52-31.png)

> ```java
> System.out.printf("%1$s %2$tB %2$te,%2$tY", "Due data:", new Date());
> System.out.printf("%s %tB %<te, %<tY", "Due date:", new Date());
> ```
>
> :o:Due date: February 9, 2015

## 5-Loops

while:

:x:use **floating-point** values for equality checking in a loop control (they are approximations for some values)

> ```java
> double item = 1; double sum = 0;
> while(item != 0) { // No guarantee item will be 0
> sum += item;
> item -= 0.1;
> }
> System.out.println(sum);
> ```

do-while:

```java
do {
    Statement(s);
} while (loop-continuation-condition);
```

for:

```java
for (initial-action; loop-continuation-condition; action-after-each-iteration) {
Statement(s);
}
```

:anchor:correct, but rarely used:

```java
for (int i= 1; i< 100; System.out.println(i++));
```

```java
for (int i= 0, j = 0; (i+ j < 10); i++, j++) {
// Do something
}
```

`break` and `continue`

带标签，可以实现智能**跳出**语句块，更加灵活

```java
label_break:
{
    if (condition) break label_break; // exit block
}
// jumps here
```

```java
label_continue:
for(...) {
    if (condition) continue label_continue；
    ...
    // jumps here
}
```

for-in:

```java
float[] f = new float[10];
for(int i = 0; i < 10; i++)
    f[i] = rand.nextFloat();
for(float x : f)
    System.out.println(x);
```

:dart:range()方法：

Java 8中，可以利用它来建立流（后面详细讲stream）

(表示简单，考试经常出填空题等)

## 6-Methods

*Method signature* is the combination of the method name and the parameter list. (e.g. `max(int num, in num2)`)
（同一个类里的方法构成重载时， method signature不一样）

When a method is invoked, you pass a value to the parameter. This value is referred to as *actual parameter* or *argument*.
（调用方法时，传递参数的值，方法内值变，但是方法外值不变，内外共压栈两次）

value-returning method中，return语句应该覆盖全部情况

> logically correct, but has a compilation error:
>
> ```java
> public static int sign(int n) {
>     if (n > 0)
>         return 1;
>     else if (n == 0)
>         return 0;
>     else if (n < 0)		// else
>         return -1;
> }
> ```

类外方法调用：`ClassName.methodName`

重载 *Overloading Methods*:

```java
public static int max(int num1, int num2);
public static double max(double num1, double num2);
```

（可以在同一个类里但signature得不一样，也可以在有继承关系的不同类里）

*Ambiguous invocation* is a compile error:

> 构成重载，但是有编译错误：
>
> ```java
> public class AmbiguousOverloading {
>     public static void main(String[] args) {
>         System.out.println(max(1, 2));
>     }
>     public static double max(int num1, double num2) {
>         ...
>     }
>     public static double max(double num1, int num2) {
>         ...
>     }
> }
> ```

*Scope* of Local Variables:

starts from its declaration and continues to the end of the block that contains the variable. (cannot declare a local variable twice in nested blocks.)

<span alt="dotted">Case Study</span>:

1. generate a random integer between 0 and 65535.

   `(int)(Math.random() * (65535 + 1))`

2. generate a random integer between `(int)'a'` and `(int)'z'`. (The Unicode for `'a'` is `(int)'a'`)

   `(int)((int)'a' + Math.random() * ((int)'z' - (int)'a' + 1))`
   The char operand is cast into a number if the other operand is a number or a character. So, the preceding expression can be simplified as follows:
   `'a' + Math.random() * ('z' - 'a' + 1)`

3. generate a random lowercase letter.
   `(char)('a' + Math.random() * ('z' - 'a' + 1))`

*Developing programs:*

- Design: stepwise refinement (divide and conquer)
- Implementation: top-down, bottom-up

## 7-Single-Dimensional Arrays

Java中没有指针的概念，只有reference

- *声明（declare）*：`datatype[] arrayRefVar;`
  `datatype arrayRefVar[];` is allowed, but not preferred.

- *创建（create）*：`arrayRefVar = new datatype[arraySize];`

- in one step: `datatype[] arrayRefVar = new datatype[arraySize];`

- 创建的数组长度固定不可变：`arrayRefVar.length`

- *default value*:
  `0`(numeric), `\u0000`(char), `false`(boolean)

- Declaring, creating, initializing using the Shorthand Notation:
  `double[] myList = {1.9, 2.4, 3.6, 5.7};`

  > :x:syntax error: 没有创建数组就进行初始化
  >
  > ```java
  > double[] myList;
  > myList = {1.9, 2.4, 3.6, 5.7};
  > ```

#### Java数组 VS. C++数组

- Java数组分配在堆上。C++中，`int a[100]`分配在栈上，`int* a = new int[100]`分配在堆上。
- Java中，`int a[100];`:x: (syntax error)
- Java中的`[]`运算符被预定义为检查数组边界，而且没有指针运算，就不能通过`a+1`得到下一个元素。

- 命令行参数，带有`String[] args`，在Java中`args`不存储程序名，`args[0]`就是第一个参数。

#### Processing Arrays

*Initializing* arrays with input values:

```java
java.util.Scanner input = new java.util.Scanner(System.in);
System.out.print("Enter " + myList.length + " values: ");
for(int i = 0; i < myList.length; i++)
	myList[i] = input.nextDouble();
```

*Coping* Arrays:

浅拷贝 `list2 = list1;`（实际上二者指向一个内容，一改俱改）

深拷贝 using a loop

`System.arraycopy` Utility: 

```java
arraycopy(sourceArray, src_pos, targetArray, tar_pos, length);
```

`Arrays.copyOf`:

```java
int[] copiedLuckyNumbers = Arrays.copyOf(luckNumbers,luckyNumbers.length);
```

第2个参数是新数组的长度，这个方法通常用来增加数组的大小

如果数组元素是数值型，则多余的元素被赋值为0；若是布尔型，则赋值为false。如果长度小于原始数组长度，则只拷贝前面的元素。

> :interrobang: 区别两个函数 [Arrays.copyOf和System.arraycopy](https://blog.csdn.net/qq_35153847/article/details/106963310)

*Passing Arrays to Methods*:

```java
public static void printArray(int[] array){...}
// invoke the method
// example 1
int[] list = {3, 2, 4, 1, 8};
printArray(list);
// example 2 -- Anonymous array 匿名数组
printArray(new int[]{3, 2, 4, 1, 8});
```

> :o:There are important differences between passing a value of variables of primitive data types and passing arrays.
>
> :anchor:For a parameter of a <u>primitive type value</u>, the actual value is passed. Changing the value of the local parameter inside the method <u>does not affect</u> the value of the variable outside the method.
>
> :anchor:For a parameter of an <u>array type</u>, the value of the parameter contains a reference to an array; this reference is passed to the method. Any changes to the array that occur inside the method body <u>will affect</u> the original array that was passed as the argument.

Linear Search, Binary Search

Selection Sort

> :o:Java provides several overloaded sort methods for sorting an array of int, double, char, short, long, and float in the `java.util.Arraysclass`.
>
> ```java
> double[] numbers = {5.4, 3.2, 5.9, 1.0};
> java.util.Arrays.sort(numbers);
> ```

## 8-Multidimensional Arrays

`dataType[][] refVar;`

`refVar = new dataType[10][10];`

=> `dataType[][] = new dataType[10][10];`

```java
int[][] array = {
    {1, 2, 3},
    {4, 5, 6},	// array.length = 4
    {7, 8, 9},	// array[0].length = 3
    {10, 11, 12}
};
// array[4].length: ArrayIndexOutOfBoundsException
```

Each row in a two-dimensional array is itself an array. So, the rows can have different lengths.

> *ragged array*（锯齿状数组）:
>
> ```java
> int[][] matrix = {
> {1, 2, 3, 4, 5},
> {2, 3, 4, 5},
> {3, 4, 5},
> {4, 5},
> {5}
> };
> ```

创建的过程也可以分开两步

> :question:以下二维数组的定义正确的是
>
> A.`int a[3][2] = {{1,2},{1,3},{2,3}}`
>
> :o:B.`int a[][] = new int[3][]`（但是后续还要new一下）
>
> C.`int[][] a = new int[][3]`
>
> D.`int[][] a = new int[][]`

## 9-Objects and Classes

java，完全面向对象，没有全局变量/方法

Constructor (do not have a return type, using `new` operator, default ctor只有在没有显式构造函数的时候—只定义显式有参的构造函数调用无参会编译错误)

```java
Circle myCircle = new Circle(5.0);
// Circle myCircle: declare --> stack
// new Circle(5.0): create --> heap
// =: assign object reference to myCircle
```



static和instant

-35

35 检查有没有reference指向，无指向的自动回收掉

36显式设置回收（不是立马回收，而是有检查机制等有空闲了回收）

37泄露：ref仍让指向，内容不会被回收

两个典型的类



46成员变量/方法

78不可变对象



91不可变类，对其修改的时候，其实是生成新的对象

95 false true（后面讲分装类）



## 10-Thinking in Objects

面向对象=>抽象和封装

## 11-Inheritance and Polymorphism

### Inheritance继承

```java
class A extends B {}
```

子类不会继承父类的构造函数，利用`super`在子类构造函数中调用父类构造函数（没有显式使用`super`时，默认调用无参的构造函数）

```java
public A() { }
<==>
public A() {
    super();
}
```

```java
public A(double d) {...}
<==>
public A(double d) {
    super();
    ...
}
```

> ```java
> public class Apple extends Fruit { }
> class Fruit {
>     public Fruit (String name) {
>         System.out.println("xxx");
>     }
> }
> ```
>
> :x:error: 应该调用Fruit的无参构造函数，但是没定义

用`super`调用父类方法：

```java
public void printCircle() {
    System.out.println("The circle is created" + super.getDataCreated() + "and the radius is " + radius);
}
```

`method override`方法重写：

要能被子类访问到（private不行，此时子类中可以重新定义一个同名的方法，但这两个方法是无关的），不能是`static`方法（子类中若有，则二者也无关，不是`override`）

使用`override`注解，可以防止非法错误（编译器会报错）

```java
@override public boolean equals(Bigram b) {
    return b.first == first && b.second == second;
}
```

`overload`方法的选择是静态的，`override`方法的选择是动态的

> ```java
> public class CollectionClassifier {
>     public static String classify(Set<?> s) {
>         return "Set";
>     }
>     public static String classify(List<?> l) {
>         return "List";
>     }
>     public static String classify(Collection<?> c) {
>         return "Unknown Collection";
>     }
>     public static void main(String[] args) {
>         Collection<?>[] collections = {new HashSet<String>(), new ArrayList<Integer>(), new HashMap<Integer, String>().values()};
>         for (Collection<?> c : collections) {
>             System.out.println(classify(c));
>         }
>     }
> }
> // output
> Unknown Collection
> Unknown Collection
> Unknown Collection
> ```
>
> :cactus:overload静态匹配参数

Java中所有的类都是从`Object`（`java.lang.Object`）中继承的：

```java
public class Circle {}
<==>
public class Circle extends Object {}
```

:anchor:`toString()`

默认函数返回`class_name@a_number_representing_this_object`

常常要自己重写来实现`tostring()`

> ```java
> Loan loan = new Loan();
> System.out.println(loan.toString());
> // output
> Loan@15037e5
> ```

### Polymorphism多态

a variable of a `supertype` can refer to a `subtype` object.

`dynamic binding`动态绑定：具体实现在Java虚拟机跑程序时决定

```java
public class PolymorphismDemo {
    public static void main(String[] args) {
        m(new GraduateStudent());
        m(new Student());
        m(new Person());
        m(new Object());
    }
    public static void m(Object x) {
        System.out.println(x.toString());
    }
}

class GraduateStudent extends Student {}
class Student extends Person {
    public String toString() {
        return "Student";
    }
}
class Person extends Object {
    public String toString() {
        return "Person";
    }
}

// output
Student
Student
Person
java.lang.Object@15db9742
```

`method matching` (according to parameter type,number of parameters, and order of the parameter) : compilation time

`dynamically binding`: runtime

这其中有隐式转换：

```java
m(new Student());
<= implicit casting =>
Object o = new Student();
m(o);
```

>:x:`Student b = o;` compile error ==>:o:`Student b = (Student o)` but this type of casting may not always succeed.
>
>:o:`Object o = new Student()`

:anchor:`instanceof`: test whether an object is an instance of a class

```java
Object myObject = new Circle();
...
if (myObject instanceof Circle) {
    System.out.println("xxx")
}
```

类型转换失败时，c++生成`null`对象，而java是抛出异常：

```c++
Manager* boss = dynamic_cast<Manager*>(staff); // c++
if (boss != NULL) ...
```

```java
if (staff instanceof Manager) {
    Manager boss = (Manager)staff;
}
```

在父类构造函数中调用被重写的方法，可能有意想不到的结果：

```java
class Base {
    public int a = 1;
    public Base() {
        test();
    }
    public void test() {
        System.out println("Base.test(): " + a);
    }
}
public class Child extends Base {
    public int a = 123;
    public Child() {}
    public void test() {
        System.out.println("Child.test(): " + a);
    }
    public static void main(String[] args) {
        Child c = new Child();
        c.test();
    }
}
// output
Child.test(): 0
Child.test(): 123
```

初始化对象的存储空间为零或null值->调用父类Ctor->按顺序调用类成员变量和实例成员变量的初始化表达式->调用本身Ctor

对于上述代码，如果加入`Base b = c;`，则`b.a == 1; c.a == 123`

对于static方法，没有动态绑定（可继承但是没有重写），传入是什么类型就调用对应类型的函数

:anchor:`equals`

默认实现为`return this == obj;`，即判断whether two objects have the same references，因此经常需要自己重写

```java
String str1 = new String("abc");
String str2 = new String("abc");
String str3 = "abc";
String str4 = "abc";
System.out.println(str1.equals(str2)); // 1
System.out.println(str1 == str2); // 0
System.out.println(str3.equals(str4)); // 1
System.out.println(str3 == str4); // 1，常量池
```

`protected`:

A protected data or a protected method in a public class can be accessed by any class in the **same package or its subclasses**, even if the subclasses are in a different package.

| Modifier  | same class |       same package       |         subclass         |    different package     |
| :-------: | :--------: | :----------------------: | :----------------------: | :----------------------: |
|  public   |    :o:     |           :o:            |           :o:            |           :o:            |
| protected |    :o:     |           :o:            |           :o:            | :heavy_multiplication_x: |
|  default  |    :o:     |           :o:            | :heavy_multiplication_x: | :heavy_multiplication_x: |
|  private  |    :o:     | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: |

Subclass **cannot weaken** the accessibility:

:o:superclass`protected` —> subclass`public`

复习`final`: class - cannot be extended, variable - constant, method - cannot be overriden

继承实现过程：

```java
public class Base {
    public static int s;
    private int a;
    static {
        System.out.println("B static, s: " + s);
        s = 1;
    }
    {
        System.out.println("B instance, a: " + a);
        a = 2;
    }
    public Base() {
        System.out.println("B ctor, a: " + a);
        a = 3;
    }
    public void step() {
        System.out.println("B step, s/a: "+s+","+a);
    }
    public void action() {
        System.out.println("start action");
        step();
        System.out.println("end action");
    }
}
```

```java
public class Child extends Base {
    public static int s;
    private int a;
    static {
        System.out.println("C static, s: " + s);
        s = 100;
    }
    {
        System.out.println("C instance, a: " + a);
        a = 200;
    }
    public Child() {
        System.out.println("C ctor, a: " + a);
        a = 300;
    }
    public void step() {
        System.out.println("C step, s/a: "+s+","+a);
    }
    public static void main(String[] args) {
        System.out.println("-----new Child()-----");
        Child c = new Child();
        System.out.println("-----c.action()-----");
        c.action();
        Base b = c;
        System.out.println("-----b.action()-----");
        b.action();
        System.out.println("b.s: "+b.s+", c.s: "+c.s);
    }
}
// output
B static, s: 0
C static, s: 0
-----new Child()-----
B instance, a: 0
B ctor, a: 2
C instance, a: 0
C ctor, a: 200
-----c.action()-----
start action
C step, s/a: 100,300
end action
-----b.action()-----
start action
C step, s/a: 100,300
end action
b.s: 1, c.s: 100
```

